<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiffusionBlocks</title>
    <style>
        body {
    margin: 0;
    overflow: hidden;
}

canvas {
    display: block;
}
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <!-- If you're not using ES6 modules in your JS, you can remove type="module" -->
    <script>

// let grid, next;
// let dA = 01; // Adjusted diffusion rate for A
// let dB = 0.125; // Adjusted diffusion rate for B
// let dC = .05;
// let feed = 0.0367; // Adjusted feed rate
// let kill = 0.0649; // Adjusted kill rate
let colorA, colorB, colorC;
let offScreenCanvas;
let sizeChoice = [25, 50, 75, 100, 125];
let canvasSize;
let offsetX, offsetY;
let gridSizeChoice = [1, 2, 3, 4];
let gridSize;
let grid = [];
let next = [];
let sectionPalettes = [];
let mergedSections = {}; // Keeps track of sections that have been merged
let colorPalettes = [
  // Palette 1
  [[255, 0, 0], [0, 102, 255], [255, 204, 0]],
  
  // Palette 2
  [[255, 128, 0], [0, 153, 51], [255, 0, 153]],
  
  // Palette 3
  [[255, 255, 0], [51, 204, 204], [255, 102, 0]],
  
  // Palette 4
  [[255, 0, 128], [102, 255, 51], [0, 102, 255]],
  
  // Palette 5
  [[204, 0, 255], [255, 255, 51], [0, 153, 204]],
  
  // Palette 6
  [[255, 0, 51], [102, 204, 0], [255, 102, 204]],
  
  // Palette 7
  [[255, 102, 0], [0, 153, 255], [255, 255, 0]],
  
  // Palette 8
  [[204, 255, 0], [51, 102, 255], [255, 0, 51]],
  
  // Palette 9
  [[255, 51, 51], [0, 204, 102], [255, 153, 0]],
  
  // Palette 10
  [[255, 51, 153], [0, 255, 102], [204, 0, 255]]
];


function setup() {
  dA = random(.5, 1); // Adjusted diffusion rate for A
  dB = random(0.05, 0.25); // Adjusted diffusion rate for B
  dC = random(0.05, 0.15);
  feed = random(0.03, 0.04);
  kill = random(0.057, 0.065);
  gridSize = random(gridSizeChoice);
  createCanvas(windowWidth, windowHeight);
  canvasSize = int(floor(random(sizeChoice)));
  offsetX = (width - canvasSize) / 2;
  offsetY = (height - canvasSize) / 2;

  // Assign palettes to sections
  for (let i = 0; i < gridSize; i++) {
    sectionPalettes[i] = [];
    for (let j = 0; j < gridSize; j++) {
        let randomPaletteIndex = floor(random(colorPalettes.length));
        sectionPalettes[i][j] = colorPalettes[randomPaletteIndex];
        }
    }

  for (let x = 0; x < canvasSize; x++) {
    grid[x] = [];
    next[x] = [];
    for (let y = 0; y < canvasSize; y++) {
      grid[x][y] = { a: 1, b: 0 };
      next[x][y] = { a: 1, b: 0 };
      grid[x][y].c = 0;  // initialize C to 0 everywhere
      next[x][y].c = 0;
    }
  }

  shuffle(colorPalettes, true); // Shuffle the palettes

  for (let i = 1; i < gridSize; i++) {
    for (let j = 1; j < gridSize; j++) {
      let paletteIndex = i * gridSize + j;
      if (paletteIndex >= colorPalettes.length) continue;
      let currentPalette = colorPalettes[paletteIndex];

      let mergedVertically = mergedSections[`${i + 1},${j}`] === true;
      let mergedHorizontally = mergedSections[`${i},${j + 1}`] === true;

      if (mergedSections[`${i},${j}`]) continue; // Skip sections that have been merged

      let sectionWidth = canvasSize / gridSize;
      let sectionHeight = canvasSize / gridSize; // Assuming a square grid, adjust if it's a rectangular grid.

      // If a section has been merged and is 2x1:
      if (mergedVertically) {
        sectionHeight *= 2;
      }
      // If a section has been merged and is 1x2:
      if (mergedHorizontally) {
        sectionWidth *= 2;
    }

initRectangleInCenter(i, j, sectionWidth, sectionHeight, currentPalette);

// Check for neighbors with the same palette
if (i + 1 < gridSize && colorPalettes[(i + 1) * gridSize + j] === currentPalette) {
  sectionHeight = 2; 
  mergedSections[`${i + 1},${j}`] = true;
} else if (j + 1 < gridSize && colorPalettes[i * gridSize + j + 1] === currentPalette) {
  sectionWidth = 2; 
  mergedSections[`${i},${j + 1}`] = true;
}

      // Check for neighbors with the same palette
      if (i + 1 < gridSize && colorPalettes[(i + 1) * gridSize + j] === currentPalette) {
        sectionHeight *= 2; // Double the height if we merge vertically
        mergedSections[`${i + 1},${j}`] = true;
      } else if (j + 1 < gridSize && colorPalettes[i * gridSize + j + 1] === currentPalette) {
        sectionWidth *= 2; // Double the width if we merge horizontally
        mergedSections[`${i},${j + 1}`] = true;
      }

      initMergedSection(i, j, sectionWidth, sectionHeight, currentPalette);
    }
  }


  // Assign random colors to chemicals A and B
  // colorA = color(random(255), random(255), random(255));
  // colorB = color(random(255), random(255), random(255));
  // colorC = color(random(255), random(255), random(255));

  frameRate(120);

  offScreenCanvas = createGraphics(canvasSize, canvasSize);
}

function initMergedSection(i, j, sectionWidth, sectionHeight, palette) {
  let startX = i;
  let endX = i + sectionWidth;
  let startY = j;
  let endY = j + sectionHeight;

  for (let x = startX; x < endX; x++) {
    for (let y = startY; y < endY; y++) {
      if(grid[x] && grid[x][y]) { // Ensure that the grid cell exists before modifying
        grid[x][y].b = 1;
        grid[x][y].palette = palette; 
      }
    }
  }
}

function initRectangleInCenter(i, j, sectionWidth, sectionHeight, palette) {
  let centerX = i * sectionWidth + sectionWidth / 2;
  let centerY = j * sectionHeight + sectionHeight / 2;

  // Define the size of the rectangle as 20% of the section width and height
  let rectWidth = sectionWidth * 0.2;
  let rectHeight = sectionHeight * 0.2;

  let startX = Math.max(0, Math.floor(centerX - rectWidth / 2));
  let endX = Math.min(canvasSize, Math.ceil(centerX + rectWidth / 2));
  let startY = Math.max(0, Math.floor(centerY - rectHeight / 2));
  let endY = Math.min(canvasSize, Math.ceil(centerY + rectHeight / 2));

  for (let x = startX; x < endX; x++) {
    for (let y = startY; y < endY; y++) {
      grid[x][y].b = 1;
      grid[x][y].palette = palette; // Assign the selected palette to the current square
    }
  }
}

function draw() {
 

  offScreenCanvas.background(220);

  // Replace all drawing operations from main canvas to offscreenCanvas
  offScreenCanvas.loadPixels(); // Use this instead of loadPixels()

  for (let x = 1; x < canvasSize - 1; x++) {
    for (let y = 1; y < canvasSize - 1; y++) {
      let a = grid[x][y].a;
      let b = grid[x][y].b;
      let c = grid[x][y].c;
      next[x][y].a = constrain(a + (dA * laplaceA(x, y)) - (a * b * b) + (feed * (1 - a)) - 1, 0, 0);
      next[x][y].b = constrain(b + (dB * laplaceB(x, y)) + (a * b * b) - ((kill + feed) * b), 0, 0);
      next[x][y].c = constrain(c + (dC * laplaceC(x, y)) - (a * b * c) + (feed * (1 - c)), 0, 2);
    }
  }

  for (let x = 0; x < canvasSize; x++) {
                for (let y = 0; y < canvasSize; y++) {
                    let i = floor(x / (canvasSize / gridSize));
                    let j = floor(y / (canvasSize / gridSize));

                    let selectedPalette = sectionPalettes[i][j];
                    colorA = color(selectedPalette[0][0], selectedPalette[0][1], selectedPalette[0][2]);
                    colorB = color(selectedPalette[1][0], selectedPalette[1][1], selectedPalette[1][2]);
                    colorC = color(selectedPalette[2][0], selectedPalette[2][1], selectedPalette[2][2]);

                    let a = next[x][y].a;
                    let b = next[x][y].b;
                    let c = next[x][y].c;
                    let col = lerpColor(lerpColor(colorA, colorB, b), colorC, c);
                    offScreenCanvas.set(x, y, col);
                }
            }
  offScreenCanvas.updatePixels();
  swap();

  // Now, display the content of offscreenCanvas on the main canvas
  // Calculate scale factor based on smaller dimension of the window
  let scaleFactor = min(windowWidth, windowHeight) / canvasSize;
  image(offScreenCanvas, (windowWidth - canvasSize * scaleFactor) / 2, (windowHeight - canvasSize * scaleFactor) / 2, canvasSize * scaleFactor, canvasSize * scaleFactor);
}

function laplaceA(x, y) {
  let sumA = 0;
  sumA += grid[x][y].a * -1;
  sumA += grid[x-1][y].a * 0.2;
  sumA += grid[x+1][y].a * 0.2;
  sumA += grid[x][y-1].a * 0.2;
  sumA += grid[x][y+1].a * 0.2;
  sumA += grid[x-1][y-1].a * 0.05;
  sumA += grid[x+1][y-1].a * 0.05;
  sumA += grid[x+1][y+1].a * 0.05;
  sumA += grid[x-1][y+1].a * 0.05;
  return sumA;
}

function laplaceB(x, y) {
  let sumB = 0;
  sumB += grid[x][y].b * -1;
  sumB += grid[x-1][y].b * 0.2;
  sumB += grid[x+1][y].b * 0.2;
  sumB += grid[x][y-1].b * 0.2;
  sumB += grid[x][y+1].b * 0.2;
  sumB += grid[x-1][y-1].b * 0.05;
  sumB += grid[x+1][y-1].b * 0.05;
  sumB += grid[x+1][y+1].b * 0.05;
  sumB += grid[x-1][y+1].b * 0.05;
  return sumB;
}

function laplaceC(x, y) {
    let sumC = 0;
    // Define the Laplacian for C, similar to A and B
    sumC += grid[x][y].c * -1;
    sumC += grid[x-1][y].c * 0.2;
    sumC += grid[x+1][y].c * 0.2;
    sumC += grid[x][y-1].c * 0.2;
    sumC += grid[x][y+1].c * 0.2;
    sumC += grid[x-1][y-1].c * 0.05;
    sumC += grid[x+1][y-1].c * 0.05;
    sumC += grid[x+1][y+1].c * 0.05;
    sumC += grid[x-1][y+1].c * 0.05;
    return sumC;
}

function swap() {
  let temp = grid;
  grid = next;
  next = temp;
}

    </script>
</body>

</html>