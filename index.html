<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiffusionBlocks</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        let colorA, colorB, colorC;
        let offScreenCanvas;
        let sizeChoice = [50, 75, 100];
        let canvasSize;
        let offsetX, offsetY;
        let gridSizeChoice = [1, 2, 3, 4];
        let gridSize;
        let grid = [];
        let next = [];
        let sectionConnectionBlocks = []
        let sectionPalettes = [];
// let mergedSections = {}; // Keeps track of sections that have been merged
let colorPalettes = [
  // Palette 1
  [[255, 0, 0], [0, 102, 255], [255, 204, 0]],
  
  // Palette 2
  [[255, 128, 0], [0, 153, 51], [255, 0, 153]],
  
  // Palette 3
  [[255, 255, 0], [51, 204, 204], [255, 102, 0]],
  
  // Palette 4
  [[255, 0, 128], [102, 255, 51], [0, 102, 255]],
  
  // Palette 5
  [[204, 0, 255], [255, 255, 51], [0, 153, 204]]
];


function setup() {
            dA = random(.5, 1);
            dB = random(0.05, 0.25);
            dC = random(0.05, 0.15);
            feed = random(0.03, 0.04);
            kill = random(0.057, 0.065);
            gridSize = random(gridSizeChoice);
            createCanvas(windowWidth, windowHeight);
            canvasSize = int(floor(random(sizeChoice)));
            offsetX = (width - canvasSize) / 2;
            offsetY = (height - canvasSize) / 2;

            for (let i = 0; i < gridSize; i++) {
                sectionPalettes[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    let randomPaletteIndex = floor(random(colorPalettes.length));
                    sectionPalettes[i][j] = colorPalettes[randomPaletteIndex];
                }
            }

            for (let x = 0; x < canvasSize; x++) {
                grid[x] = [];
                next[x] = [];
                for (let y = 0; y < canvasSize; y++) {
                    grid[x][y] = { a: 1, b: 0 }; // Setting default values
                    next[x][y] = { a: 1, b: 0 };
                    grid[x][y].c = 0;
                    next[x][y].c = 0;
                }
            }

            shuffle(colorPalettes, true);

            for (let i = 1; i < gridSize; i++) {
                for (let j = 1; j < gridSize; j++) {
                    let paletteIndex = i * gridSize + j;
                    if (paletteIndex >= colorPalettes.length) continue;
                    let currentPalette = colorPalettes[paletteIndex];
                    let sectionWidth = canvasSize / gridSize;
                    let sectionHeight = canvasSize / gridSize;
                    initRectangleInCenter(i, j, sectionWidth, sectionHeight, currentPalette);
                }
            }

            frameRate(120);
            offScreenCanvas = createGraphics(canvasSize, canvasSize);
        }

        function initRectangleInCenter(i, j, sectionWidth, sectionHeight, palette) {
            let centerX = i * sectionWidth + sectionWidth / 2;
            let centerY = j * sectionHeight + sectionHeight / 2;
            let rectWidth = sectionWidth * 0.2;
            let rectHeight = sectionHeight * 0.2;
            let startX = Math.max(0, Math.floor(centerX - rectWidth / 2));
            let endX = Math.min(canvasSize, Math.ceil(centerX + rectWidth / 2));
            let startY = Math.max(0, Math.floor(centerY - rectHeight / 2));
            let endY = Math.min(canvasSize, Math.ceil(centerY + rectHeight / 2));

            for (let x = startX; x < endX; x++) {
                for (let y = startY; y < endY; y++) {
                    grid[x][y].b = 1;  // Seeding chemical B based on the blocks
                    grid[x][y].palette = palette;
                }
            }
        }

        function drawSectionConnections() {
    let centroids = computeCentroids();
    let sectionGirth = canvasSize / gridSize;
    let blockWidth = sectionGirth * 0.35;
    let blockLength = sectionGirth + blockWidth; // Increased length
    let visited = {};
    offScreenCanvas.noStroke();

    for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
            let currentPalette = sectionPalettes[i][j];
            let neighbors = [
                { dx: 0, dy: -1 }, // up
                { dx: 0, dy: 1 },  // down
                { dx: -1, dy: 0 }, // left
                { dx: 1, dy: 0 }   // right
            ];

            for (let n of neighbors) {
                let ni = i + n.dx;
                let nj = j + n.dy;

                if (ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize) {
                    let neighborPalette = sectionPalettes[ni][nj];
                    let key1 = `${i},${j},${ni},${nj}`;
                    let key2 = `${ni},${nj},${i},${j}`;

                    if (isEqualPalette(currentPalette, neighborPalette) && !visited[key1] && !visited[key2]) {
                        // Use the color of chemicalB from the section's color palette
                        let chemicalBColor = color(currentPalette[1][0], currentPalette[1][1], currentPalette[1][2], 155); // 50% transparency
                        offScreenCanvas.fill(chemicalBColor);

                        let start = centroids[i][j];
                        let end = centroids[ni][nj];
                        let rectX, rectY, rectWidth, rectHeight;

                        if (n.dx !== 0) { // left or right
                            rectX = start.x - blockWidth/2 * n.dx;
                            rectY = start.y - blockWidth/2;
                            rectWidth = blockLength * n.dx;
                            rectHeight = blockWidth;
                        } else { // up or down
                            rectX = start.x - blockWidth/2;
                            rectY = start.y - blockWidth/2 * n.dy;
                            rectWidth = blockWidth;
                            rectHeight = blockLength * n.dy;
                        }

                        // Setting chemical B values for the grid locations covered by the rectangle
                        for (let rx = Math.floor(rectX); rx < rectX + rectWidth; rx++) {
                            for (let ry = Math.floor(rectY); ry < rectY + rectHeight; ry++) {
                                if (rx >= 0 && ry >= 0 && rx < canvasSize && ry < canvasSize) {
                                    grid[rx][ry].b = 1;
                                }
                            }
                        }

                        offScreenCanvas.rect(rectX, rectY, rectWidth, rectHeight);
                        visited[key1] = true;
                    }
                }
            }
        }
    }
}



function computeCentroids() {
    let centroids = [];

    for (let i = 0; i < gridSize; i++) {
        centroids[i] = [];
        for (let j = 0; j < gridSize; j++) {
            let sectionWidth = canvasSize / gridSize;
            let sectionHeight = canvasSize / gridSize;

            let centerX = (i + 0.5) * sectionWidth;
            let centerY = (j + 0.5) * sectionHeight;

            centroids[i][j] = { x: centerX, y: centerY };
        }
    }

    return centroids;
}

function isEqualPalette(palette1, palette2) {
    for (let i = 0; i < palette1.length; i++) {
        for (let j = 0; j < palette1[i].length; j++) {
            if (palette1[i][j] !== palette2[i][j]) return false;
        }
    }

    return true;
}

function draw() {
 
  drawSectionConnections();

  offScreenCanvas.background(220);

  // Replace all drawing operations from main canvas to offscreenCanvas
  offScreenCanvas.loadPixels(); // Use this instead of loadPixels()

  for (let x = 1; x < canvasSize - 1; x++) {
    for (let y = 1; y < canvasSize - 1; y++) {
      let a = grid[x][y].a;
      let b = grid[x][y].b;
      let c = grid[x][y].c;
      next[x][y].a = constrain(a + (dA * laplaceA(x, y)) - (a * b * b) + (feed * (1 - a)), 0, 1);
      next[x][y].b = constrain(b + (dB * laplaceB(x, y)) + (a * b * b) - ((kill + feed) * b), 0, 1);
      next[x][y].c = constrain(c + (dC * laplaceC(x, y)) - (a * b * c) + (feed * (1 - c)), 0, 1);

    }
  }

  for (let x = 0; x < canvasSize; x++) {
                for (let y = 0; y < canvasSize; y++) {
                    let i = floor(x / (canvasSize / gridSize));
                    let j = floor(y / (canvasSize / gridSize));

                    let selectedPalette = sectionPalettes[i][j];
                    colorA = color(selectedPalette[0][0], selectedPalette[0][1], selectedPalette[0][2]);
                    colorB = color(selectedPalette[1][0], selectedPalette[1][1], selectedPalette[1][2]);
                    colorC = color(selectedPalette[2][0], selectedPalette[2][1], selectedPalette[2][2]);

                    let a = next[x][y].a;
                    let b = next[x][y].b;
                    let c = next[x][y].c;
                    let col = lerpColor(lerpColor(colorA, colorB, b), colorC, c);
                    offScreenCanvas.set(x, y, col);
                }
            }
  offScreenCanvas.updatePixels();
  drawBoundaries();
  // Draw the connections between sections
  swap();

  // Now, display the content of offscreenCanvas on the main canvas
  // Calculate scale factor based on smaller dimension of the window
  let scaleFactor = min(windowWidth, windowHeight) / canvasSize;
  image(offScreenCanvas, (windowWidth - canvasSize * scaleFactor) / 2, (windowHeight - canvasSize * scaleFactor) / 2, canvasSize * scaleFactor, canvasSize * scaleFactor);
}

function drawBoundaries() {
    offScreenCanvas.stroke(0); // Black color for boundaries
    let sectionWidth = canvasSize / gridSize;
    let sectionHeight = canvasSize / gridSize;

    for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
            // Check for boundary on the right
            if (i < gridSize - 1 && !arraysEqual(sectionPalettes[i][j], sectionPalettes[i + 1][j])) {
                offScreenCanvas.line((i + 1) * sectionWidth, j * sectionHeight, (i + 1) * sectionWidth, (j + 1) * sectionHeight);
            }
            // Check for boundary on the bottom
            if (j < gridSize - 1 && !arraysEqual(sectionPalettes[i][j], sectionPalettes[i][j + 1])) {
                offScreenCanvas.line(i * sectionWidth, (j + 1) * sectionHeight, (i + 1) * sectionWidth, (j + 1) * sectionHeight);
            }
        }
    }
}

function arraysEqual(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
}

function laplaceA(x, y) {
  let sumA = 0;
  sumA += grid[x][y].a * -1;
  sumA += grid[x-1][y].a * 0.2;
  sumA += grid[x+1][y].a * 0.2;
  sumA += grid[x][y-1].a * 0.2;
  sumA += grid[x][y+1].a * 0.2;
  sumA += grid[x-1][y-1].a * 0.05;
  sumA += grid[x+1][y-1].a * 0.05;
  sumA += grid[x+1][y+1].a * 0.05;
  sumA += grid[x-1][y+1].a * 0.05;
  return sumA;
}

function laplaceB(x, y) {
  let sumB = 0;
  sumB += grid[x][y].b * -1;
  sumB += grid[x-1][y].b * 0.2;
  sumB += grid[x+1][y].b * 0.2;
  sumB += grid[x][y-1].b * 0.2;
  sumB += grid[x][y+1].b * 0.2;
  sumB += grid[x-1][y-1].b * 0.05;
  sumB += grid[x+1][y-1].b * 0.05;
  sumB += grid[x+1][y+1].b * 0.05;
  sumB += grid[x-1][y+1].b * 0.05;
  return sumB;
}

function laplaceC(x, y) {
    let sumC = 0;
    // Define the Laplacian for C, similar to A and B
    sumC += grid[x][y].c * -1;
    sumC += grid[x-1][y].c * 0.2;
    sumC += grid[x+1][y].c * 0.2;
    sumC += grid[x][y-1].c * 0.2;
    sumC += grid[x][y+1].c * 0.2;
    sumC += grid[x-1][y-1].c * 0.05;
    sumC += grid[x+1][y-1].c * 0.05;
    sumC += grid[x+1][y+1].c * 0.05;
    sumC += grid[x-1][y+1].c * 0.05;
    return sumC;
}

function swap() {
  let temp = grid;
  grid = next;
  next = temp;
}

    </script>
</body>

</html>